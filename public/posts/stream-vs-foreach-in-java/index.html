<!--
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

- -->
<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Understanding when to use stream() vs forEach() in Java"><meta property="og:description" content='In Java, choosing between Stream() and ForEach() depends on what you want to do with your data. While both are used to iterate over collections, each has its own strengths.
stream()
Using stream() is powerful for complex data transformations, allowing operations like filtering, mapping, and reducing. It&rsquo;s ideal for:

Transformations and filters: Use Stream() to apply operations like filtering, mapping, grouping, or reducing data.
Chained processing: Apply multiple operations in a single chain.
Parallel processing: For large datasets, use parallelStream() to leverage multi-core processors.
Immutability: Streams avoid side effects, allowing new collections to be generated without changing the original.

Example:
List<String> names = Arrays.asList("Maria", "José", "João");
List<String> filteredNames = names.stream()
.filter(name -> name.startsWith("J"))
.map(String::toUpperCase)
.collect(Collectors.toList());
The results will be a new list only with the names started with J in uppercase.'><meta property="og:url" content="https://adlermedrado.com.br/posts/stream-vs-foreach-in-java/"><meta property="og:site_name" content="Adler Medrado's corner of the web"><meta property="og:type" content="article"><meta property="og:image" content="/images/default-og-image.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Understanding when to use stream() vs forEach() in Java"><meta name=twitter:description content='In Java, choosing between Stream() and ForEach() depends on what you want to do with your data. While both are used to iterate over collections, each has its own strengths.
stream()
Using stream() is powerful for complex data transformations, allowing operations like filtering, mapping, and reducing. It&rsquo;s ideal for:

Transformations and filters: Use Stream() to apply operations like filtering, mapping, grouping, or reducing data.
Chained processing: Apply multiple operations in a single chain.
Parallel processing: For large datasets, use parallelStream() to leverage multi-core processors.
Immutability: Streams avoid side effects, allowing new collections to be generated without changing the original.

Example:
List<String> names = Arrays.asList("Maria", "José", "João");
List<String> filteredNames = names.stream()
.filter(name -> name.startsWith("J"))
.map(String::toUpperCase)
.collect(Collectors.toList());
The results will be a new list only with the names started with J in uppercase.'><meta name=twitter:image content="/images/default-og-image.png"><title>Understanding when to use stream() vs forEach() in Java</title><meta name=description content='In Java, choosing between Stream() and ForEach() depends on what you want to do with your data. While both are used to iterate over collections, each has its own strengths.
stream()
Using stream() is powerful for complex data transformations, allowing operations like filtering, mapping, and reducing. It&rsquo;s ideal for:

Transformations and filters: Use Stream() to apply operations like filtering, mapping, grouping, or reducing data.
Chained processing: Apply multiple operations in a single chain.
Parallel processing: For large datasets, use parallelStream() to leverage multi-core processors.
Immutability: Streams avoid side effects, allowing new collections to be generated without changing the original.

Example:
List<String> names = Arrays.asList("Maria", "José", "João");
List<String> filteredNames = names.stream()
.filter(name -> name.startsWith("J"))
.map(String::toUpperCase)
.collect(Collectors.toList());
The results will be a new list only with the names started with J in uppercase.'><link rel=author href=/humans.txt><link rel=icon type=image/png href=/images/favicon.png><link rel=canonical href=https://adlermedrado.com.br/posts/stream-vs-foreach-in-java/><link href=/css/styles.css rel=stylesheet></head><body><header class=glitch-zone><nav class=navbar role=navigation aria-label="Main Navigation"><div class=navbar_left><a href=/ class=h-card rel=me><strong>Adler Medrado<span class=cursor-blink>|</span></strong></a></div><div class="navbar_right navbar_right_animated"><a href=/posts>posts</a>
<a href=/missives>missives</a>
<a href=/now>what am i doing now</a>
<a href=/uses>what am i using</a></div></nav></header><main><section class=section><article><div><h1>Understanding when to use stream() vs forEach() in Java</h1><div><div><p><small><time>November 3, 2024</time>
|
2 minutes read</small><div class=post-tags><p><strong>Tags:</strong>
<a href=/tags/programming>programming</a>,
<a href=/tags/development>development</a>,
<a href=/tags/java>java</a>,
<a href=/tags/tips>tips</a></p></div></p></div><span class=line_break></span></div><div class=content><p>In Java, choosing between Stream() and ForEach() depends on what you want to do with your data. While both are used to iterate over collections, each has its own strengths.</p><h2 id=stream>stream()</h2><p>Using stream() is powerful for complex data transformations, allowing operations like filtering, mapping, and reducing. It&rsquo;s ideal for:</p><ul><li>Transformations and filters: Use Stream() to apply operations like filtering, mapping, grouping, or reducing data.</li><li>Chained processing: Apply multiple operations in a single chain.</li><li>Parallel processing: For large datasets, use parallelStream() to leverage multi-core processors.</li><li>Immutability: Streams avoid side effects, allowing new collections to be generated without changing the original.</li></ul><h4 id=example>Example:</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> names <span style=color:#f92672>=</span> Arrays.<span style=color:#a6e22e>asList</span>(<span style=color:#e6db74>&#34;Maria&#34;</span>, <span style=color:#e6db74>&#34;José&#34;</span>, <span style=color:#e6db74>&#34;João&#34;</span>);
</span></span><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> filteredNames <span style=color:#f92672>=</span> names.<span style=color:#a6e22e>stream</span>()
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>filter</span>(name <span style=color:#f92672>-&gt;</span> name.<span style=color:#a6e22e>startsWith</span>(<span style=color:#e6db74>&#34;J&#34;</span>))
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>map</span>(String::toUpperCase)
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>collect</span>(Collectors.<span style=color:#a6e22e>toList</span>());
</span></span></code></pre></div><p>The results will be a new list only with the names started with <em>J</em> in uppercase.</p><h2 id=foreach>forEach()</h2><p>Using forEach() is perfect for simple tasks, applying an action to each item without returning anything. Use for:</p><ul><li>Simple operations: Direct tasks without transformations or chaining.</li><li>Side effects: Modify elements in an existing collection.</li><li>Readability: Simple and direct code.</li></ul><h4 id=example-1>Example:</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> names <span style=color:#f92672>=</span> Arrays.<span style=color:#a6e22e>asList</span>(<span style=color:#e6db74>&#34;Maria&#34;</span>, <span style=color:#e6db74>&#34;José&#34;</span>, <span style=color:#e6db74>&#34;João&#34;</span>);
</span></span><span style=display:flex><span>names.<span style=color:#a6e22e>forEach</span>(name <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(name));
</span></span></code></pre></div><p>This code snippet will only print all items on the list.</p><h2 id=final-thoughts>Final Thoughts</h2><ul><li>Use Stream() for complex transformations, parallel processing, or immutability.</li><li>Use ForEach() for simple, direct operations.</li></ul><p>These two options complement each other, enabling Java developers to work with collections efficiently.</p></div></div></article><div><div><div><a href=https://adlermedrado.com.br/posts/shadowdata-updates/>&#8592; Shadowdata Updates</a>
|
<a href=https://adlermedrado.com.br/posts/boat-gig-parody/>From BBS to Blockchain: A Boat Gig Parody for Old-School Nerds &#8594;</a></div></div></div></section></main><footer class=glitch-zone role=contentinfo><div class=footer-content><div class=copyright><p><small>&copy; 1996-2025 Adler Medrado</small></p></div><div class=gpg_signed_info><p>All pages on this website are PGP signed.
Import my <a href=/pub-key.asc aria-label="Download my PGP public key">public key</a> and check with <em>curl https://adlermedrado.com.br/posts/stream-vs-foreach-in-java/ | gpg --verify</em></p><p><em>Privacy policy: this website employs no tracking.</em></p><p><span class=badge-a-plus><a href="https://developer.mozilla.org/en-US/observatory/analyze?host=adlermedrado.com.br" aria-label="Mozilla Observatory Security Rating: A+">A+</a></span>
<span class=badge-description>Mozilla Observatory Security Rating</span></p></div></div></footer></body></html><!--
-----BEGIN PGP SIGNATURE-----

iQIzBAEBCAAdFiEEB9cP28xEbBnKQwLObV8aePHcNh0FAmhUfxwACgkQbV8aePHc
Nh0QrA/8DzKCPos3/1DlJhGhqgUs+ytsvjGNjEsOIFJUiIfYvxVrwIed0ooT0o96
mXtFpvecCOEDfpUfS87s+GmSHl95B/f6C/DixqhNOYJonMRNmZDFfz9f2uuMGl1p
LTJ6MxmtnKktqyYJ8LoESJ0ii/d2+me5G7A3MUYZWoxHmACyNobqMyBbDQAc+M5Q
nu1oRUgOapAXyijQmN3ctEaLyTEaSGCZlveONK9poDcawPU0PCJ+HES9cmnM3u/+
qAUpljsQ+VcM2WcSLWKYFBsQcmbPXWfhEFVm1FDJIE9J/TC9DBgkOmr844SHvQcQ
LIeSRrKSGyWFrngcdG02X6HGtkkVnghJ5j4VHZ8b33TwLYPhvb/6XuitcZWTLGnb
2FOQ00nXwQM2BnM5tyJgq/dUVs5Gtb/3p2SJqhRX1JQHXWG1+lMdVQFgIJoQV6C7
QnuHLIFPoQjm63W3ugFdpmgU72akAF5Y5mJ+K5uwEJ8TMeO+lUFEL7muX/k2cB54
0LMeucQoCNU6CYkGy/kYzPKWysOS5zftw8WqF0KLfchcQnX2REXtn7//4FhLH9LQ
NNnlPXVehV2YTTQTqzZKFWtN0ASZvSY+ODdx4TQtp0ZF9K/U1+ZEd0+cqGqPl9gJ
RgIzG6MMvPstCpITr8OIrq0VgjErtMwBmdBAONRPCqSjPJBgkR8=
=pphF
-----END PGP SIGNATURE-----
-->
