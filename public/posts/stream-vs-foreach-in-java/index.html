<!--
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

- -->
<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Understanding when to use stream() vs forEach() in Java"><meta property="og:description" content='In Java, choosing between Stream() and ForEach() depends on what you want to do with your data. While both are used to iterate over collections, each has its own strengths.
stream()
Using stream() is powerful for complex data transformations, allowing operations like filtering, mapping, and reducing. It&rsquo;s ideal for:

Transformations and filters: Use Stream() to apply operations like filtering, mapping, grouping, or reducing data.
Chained processing: Apply multiple operations in a single chain.
Parallel processing: For large datasets, use parallelStream() to leverage multi-core processors.
Immutability: Streams avoid side effects, allowing new collections to be generated without changing the original.

Example:
List<String> names = Arrays.asList("Maria", "José", "João");
List<String> filteredNames = names.stream()
.filter(name -> name.startsWith("J"))
.map(String::toUpperCase)
.collect(Collectors.toList());
The results will be a new list only with the names started with J in uppercase.'><meta property="og:url" content="https://adlermedrado.com.br/posts/stream-vs-foreach-in-java/"><meta property="og:site_name" content="Adler Medrado's corner of the web"><meta property="og:type" content="article"><meta property="og:image" content="/images/default-og-image.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Understanding when to use stream() vs forEach() in Java"><meta name=twitter:description content='In Java, choosing between Stream() and ForEach() depends on what you want to do with your data. While both are used to iterate over collections, each has its own strengths.
stream()
Using stream() is powerful for complex data transformations, allowing operations like filtering, mapping, and reducing. It&rsquo;s ideal for:

Transformations and filters: Use Stream() to apply operations like filtering, mapping, grouping, or reducing data.
Chained processing: Apply multiple operations in a single chain.
Parallel processing: For large datasets, use parallelStream() to leverage multi-core processors.
Immutability: Streams avoid side effects, allowing new collections to be generated without changing the original.

Example:
List<String> names = Arrays.asList("Maria", "José", "João");
List<String> filteredNames = names.stream()
.filter(name -> name.startsWith("J"))
.map(String::toUpperCase)
.collect(Collectors.toList());
The results will be a new list only with the names started with J in uppercase.'><meta name=twitter:image content="/images/default-og-image.png"><title>Understanding when to use stream() vs forEach() in Java</title><meta name=description content='In Java, choosing between Stream() and ForEach() depends on what you want to do with your data. While both are used to iterate over collections, each has its own strengths.
stream()
Using stream() is powerful for complex data transformations, allowing operations like filtering, mapping, and reducing. It&rsquo;s ideal for:

Transformations and filters: Use Stream() to apply operations like filtering, mapping, grouping, or reducing data.
Chained processing: Apply multiple operations in a single chain.
Parallel processing: For large datasets, use parallelStream() to leverage multi-core processors.
Immutability: Streams avoid side effects, allowing new collections to be generated without changing the original.

Example:
List<String> names = Arrays.asList("Maria", "José", "João");
List<String> filteredNames = names.stream()
.filter(name -> name.startsWith("J"))
.map(String::toUpperCase)
.collect(Collectors.toList());
The results will be a new list only with the names started with J in uppercase.'><link rel=author href=/humans.txt><link rel=icon type=image/png href=/images/favicon.png><link rel=canonical href=https://adlermedrado.com.br/posts/stream-vs-foreach-in-java/><link href=/css/styles.css rel=stylesheet></head><body><header class=glitch-zone><nav class=navbar role=navigation aria-label="Main Navigation"><div class=navbar_left><a href=/ class=h-card rel=me><strong>Adler Medrado<span class=cursor-blink>|</span></strong></a></div><div class="navbar_right navbar_right_animated"><a href=/posts>posts</a>
<a href=/missives>missives</a>
<a href=/now>what am i doing now</a>
<a href=/uses>what am i using</a></div></nav></header><main><section class=section><article><div><h1>Understanding when to use stream() vs forEach() in Java</h1><div><div><p><small><time>November 3, 2024</time>
|
2 minutes read</small></p></div><span class=line_break></span></div><div class=content><p>In Java, choosing between Stream() and ForEach() depends on what you want to do with your data. While both are used to iterate over collections, each has its own strengths.</p><h2 id=stream>stream()</h2><p>Using stream() is powerful for complex data transformations, allowing operations like filtering, mapping, and reducing. It&rsquo;s ideal for:</p><ul><li>Transformations and filters: Use Stream() to apply operations like filtering, mapping, grouping, or reducing data.</li><li>Chained processing: Apply multiple operations in a single chain.</li><li>Parallel processing: For large datasets, use parallelStream() to leverage multi-core processors.</li><li>Immutability: Streams avoid side effects, allowing new collections to be generated without changing the original.</li></ul><h4 id=example>Example:</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> names <span style=color:#f92672>=</span> Arrays.<span style=color:#a6e22e>asList</span>(<span style=color:#e6db74>&#34;Maria&#34;</span>, <span style=color:#e6db74>&#34;José&#34;</span>, <span style=color:#e6db74>&#34;João&#34;</span>);
</span></span><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> filteredNames <span style=color:#f92672>=</span> names.<span style=color:#a6e22e>stream</span>()
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>filter</span>(name <span style=color:#f92672>-&gt;</span> name.<span style=color:#a6e22e>startsWith</span>(<span style=color:#e6db74>&#34;J&#34;</span>))
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>map</span>(String::toUpperCase)
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>collect</span>(Collectors.<span style=color:#a6e22e>toList</span>());
</span></span></code></pre></div><p>The results will be a new list only with the names started with <em>J</em> in uppercase.</p><h2 id=foreach>forEach()</h2><p>Using forEach() is perfect for simple tasks, applying an action to each item without returning anything. Use for:</p><ul><li>Simple operations: Direct tasks without transformations or chaining.</li><li>Side effects: Modify elements in an existing collection.</li><li>Readability: Simple and direct code.</li></ul><h4 id=example-1>Example:</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> names <span style=color:#f92672>=</span> Arrays.<span style=color:#a6e22e>asList</span>(<span style=color:#e6db74>&#34;Maria&#34;</span>, <span style=color:#e6db74>&#34;José&#34;</span>, <span style=color:#e6db74>&#34;João&#34;</span>);
</span></span><span style=display:flex><span>names.<span style=color:#a6e22e>forEach</span>(name <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(name));
</span></span></code></pre></div><p>This code snippet will only print all items on the list.</p><h2 id=final-thoughts>Final Thoughts</h2><ul><li>Use Stream() for complex transformations, parallel processing, or immutability.</li><li>Use ForEach() for simple, direct operations.</li></ul><p>These two options complement each other, enabling Java developers to work with collections efficiently.</p></div></div></article><div><div><div><a href=https://adlermedrado.com.br/posts/shadowdata-updates/>&#8592; Shadowdata Updates</a>
|
<a href=https://adlermedrado.com.br/posts/boat-gig-parody/>From BBS to Blockchain: A Boat Gig Parody for Old-School Nerds &#8594;</a></div></div></div></section></main><span class=line_break></span>
<span class=line_break></span><footer class=glitch-zone><div><p><small>&copy; 1996-2025 Adler Medrado</small></p></div><div class=gpg_signed_info><p>All pages on this website are PGP signed.
Import my <a href=/pub-key.asc>public key</a> and check with <em>curl https://adlermedrado.com.br/posts/stream-vs-foreach-in-java/ | gpg --verify</em></p><p><em>Privacy policy: this website employs no tracking.</em></p><p><span class=badge-a-plus>A+</span></p></div></footer></body></html><!--
-----BEGIN PGP SIGNATURE-----

iQIzBAEBCAAdFiEEB9cP28xEbBnKQwLObV8aePHcNh0FAmhA1ZYACgkQbV8aePHc
Nh10TRAAxzLAX3HEfN+zJk3FMqe2NQ4A9LmcRno86eEonktJmOIW233QmrIZFKGx
O1/JEhYl7MW0ZyR5osLAARSGuLJE9ebnrj7ETK0Bb0cQ5LKn5uzPn02G0PXAnJbM
PkOfUmCmsBB5KvHfUUd5smySQ7oIezXpHrxTXT2OdOCOzU4a7yvCEFTXS8eb1H4A
pIYCnk4eOEdjWWpW4k8lyEtAbKsjzgf+4gwseM3Cus+JqcP6vZznE4RvkGTiw7Tm
uBiQok+mg1SIU7VABrvebqW2/ZYeLuVynb3FM8x4bOcqdINjuKTVuBInW6uJZ3Vz
rNmN1p0nFMU7q1gWO3kpty3B9s2s/4yG84+Sjb5/bLqVyPiNo62ubR2SJN2lLSZT
MlXGJP4MC062z3BFYCOvnXjnQflR9/HWKM/K2t0IWZPuE6h8o7UUcZxxGh8kqBHI
E82GFVzIx9ZH+VW0WzbuFENFhI/XMe0B/B+RkqO+HDwUPeKrO+tt2CxNOtslZ7Eu
AdJwxHfEY7tXxEespaI09uXBsNSf4272uAYERHgTNoyp6PelBluSeslJghaoLDa/
6/Ewb5cViRPWqUxvl0qupFJY2d/JBhF1JEJG/DlN0/SG8fr5rvX3wc3+20gBWtai
QcqW8QmLgiTnsql/ufPLkD9uTUDA3HepZcSq1HLrZUVJHalxGh8=
=xAMU
-----END PGP SIGNATURE-----
-->
